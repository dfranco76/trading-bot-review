"""
Tests unitarios para el módulo de gestión de riesgo.
"""
import unittest
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime, timedelta

# Import usando el nombre correcto en minúsculas
from risk_management import risk_manager


class TestRiskManager(unittest.TestCase):
    """Tests para el Risk Manager real del proyecto"""
    
    def setUp(self):
        """Configuración inicial para cada test"""
        # Mock de Supabase
        self.mock_supabase = Mock()
        
        # Patch del cliente de Supabase
        self.patcher = patch('risk_management.risk_manager.supabase', self.mock_supabase)
        self.patcher.start()
        
        # Configurar respuesta por defecto para capital
        self.mock_supabase.table.return_value.select.return_value.execute.return_value.data = [
            {'capital': 200}
        ]
        
        # Crear instancia del Risk Manager
        self.risk_manager = RiskManager(capital_inicial=200)
    
    def tearDown(self):
        """Limpieza después de cada test"""
        self.patcher.stop()
    
    # ===== TESTS DE INICIALIZACIÓN =====
    def test_initialization_values(self):
        """Test que los valores se inicializan correctamente"""
        self.assertEqual(self.risk_manager.capital_inicial, 200)
        self.assertEqual(self.risk_manager.max_perdida_diaria, 0.05)
        self.assertEqual(self.risk_manager.max_perdida_trade, 0.02)
        self.assertEqual(self.risk_manager.max_drawdown_permitido, 0.10)
        self.assertEqual(self.risk_manager.max_trades_dia, 15)
        self.assertEqual(self.risk_manager.max_exposicion, 0.80)
        self.assertEqual(self.risk_manager.max_exposicion_simbolo, 0.25)
        self.assertEqual(self.risk_manager.horario_apertura, 15)
        self.assertEqual(self.risk_manager.horario_cierre, 22)
    
    # ===== TESTS DE CAPITAL =====
    def test_get_capital_actual_con_datos(self):
        """Test obtener capital cuando hay datos en BD"""
        # Configurar mock
        self.mock_supabase.table.return_value.select.return_value.execute.return_value.data = [
            {'capital': 250.50}
        ]
        
        capital = self.risk_manager.get_capital_actual()
        
        self.assertEqual(capital, 250.50)
        self.mock_supabase.table.assert_called_with('bot_status')
    
    def test_get_capital_actual_sin_datos(self):
        """Test obtener capital cuando no hay datos devuelve el inicial"""
        # Configurar mock sin datos
        self.mock_supabase.table.return_value.select.return_value.execute.return_value.data = []
        
        capital = self.risk_manager.get_capital_actual()
        
        self.assertEqual(capital, 200.0)  # Debe retornar capital inicial
    
    # ===== TESTS DE MÉTRICAS DEL DÍA =====
    def test_get_metricas_dia_sin_trades(self):
        """Test métricas cuando no hay trades en el día"""
        # Configurar mock para la consulta de trades
        mock_table = Mock()
        mock_select = Mock()
        mock_gte = Mock()
        mock_execute = Mock()
        
        mock_execute.return_value.data = []
        mock_gte.return_value.execute = mock_execute
        mock_select.return_value.gte = mock_gte
        mock_table.return_value.select = mock_select
        
        self.mock_supabase.table = mock_table
        
        metricas = self.risk_manager.get_metricas_dia()
        
        self.assertEqual(metricas['trades_totales'], 0)
        self.assertEqual(metricas['trades_ganadores'], 0)
        self.assertEqual(metricas['trades_perdedores'], 0)
        self.assertEqual(metricas['pnl_total'], 0)
        self.assertEqual(metricas['pnl_porcentaje'], 0)
        self.assertEqual(metricas['win_rate'], 0)
    
    def test_get_metricas_dia_con_trades_mixtos(self):
        """Test métricas con trades ganadores y perdedores"""
        # Configurar mock con trades
        trades_data = [
            {'id': 1, 'pnl': 10},      # Ganador
            {'id': 2, 'pnl': -5},      # Perdedor
            {'id': 3, 'pnl': 15},      # Ganador
            {'id': 4, 'pnl': None},    # Sin cerrar
        ]
        
        mock_table = Mock()
        mock_table.return_value.select.return_value.gte.return_value.execute.return_value.data = trades_data
        self.mock_supabase.table = mock_table
        
        metricas = self.risk_manager.get_metricas_dia()
        
        self.assertEqual(metricas['trades_totales'], 4)
        self.assertEqual(metricas['trades_ganadores'], 2)
        self.assertEqual(metricas['trades_perdedores'], 1)
        self.assertEqual(metricas['pnl_total'], 20)  # 10 - 5 + 15
        self.assertEqual(metricas['pnl_porcentaje'], 10.0)  # 20/200 * 100
        self.assertEqual(metricas['win_rate'], 0.5)  # 2/4
    
    # ===== TESTS DE POSICIONES ABIERTAS =====
    def test_get_posiciones_abiertas(self):
        """Test obtener posiciones abiertas"""
        posiciones_data = [
            {'symbol': 'AAPL', 'quantity': 10, 'price': 150, 'status': 'OPEN'},
            {'symbol': 'GOOGL', 'quantity': 5, 'price': 100, 'status': 'OPEN'}
        ]
        
        self.mock_supabase.table.return_value.select.return_value.eq.return_value.execute.return_value.data = posiciones_data
        
        posiciones = self.risk_manager.get_posiciones_abiertas()
        
        self.assertEqual(len(posiciones), 2)
        self.assertEqual(posiciones[0]['symbol'], 'AAPL')
        self.assertEqual(posiciones[1]['symbol'], 'GOOGL')
    
    # ===== TESTS DE EXPOSICIÓN =====
    def test_calcular_exposicion_actual_sin_posiciones(self):
        """Test calcular exposición sin posiciones abiertas"""
        # Mock sin posiciones
        self.mock_supabase.table.return_value.select.return_value.eq.return_value.execute.return_value.data = []
        
        exposicion = self.risk_manager.calcular_exposicion_actual()
        
        self.assertEqual(exposicion['exposicion_total'], 0)
        self.assertEqual(exposicion['exposicion_total_pct'], 0)
        self.assertEqual(len(exposicion['exposicion_por_simbolo']), 0)
        self.assertEqual(len(exposicion['simbolos_activos']), 0)
    
    def test_calcular_exposicion_actual_con_posiciones(self):
        """Test calcular exposición con múltiples posiciones"""
        # Mock con posiciones
        posiciones_data = [
            {'symbol': 'AAPL', 'quantity': 10, 'price': 150, 'status': 'OPEN'},  # $1500
            {'symbol': 'GOOGL', 'quantity': 5, 'price': 100, 'status': 'OPEN'},  # $500
            {'symbol': 'AAPL', 'quantity': 5, 'price': 140, 'status': 'OPEN'}   # $700
        ]
        self.mock_supabase.table.return_value.select.return_value.eq.return_value.execute.return_value.data = posiciones_data
        
        exposicion = self.risk_manager.calcular_exposicion_actual()
        
        # Total: 1500 + 500 + 700 = 2700
        self.assertEqual(exposicion['exposicion_total'], 2700)
        self.assertEqual(exposicion['exposicion_total_pct'], 13.5)  # 2700/200
        
        # Por símbolo
        self.assertEqual(exposicion['exposicion_por_simbolo']['AAPL'], 2200)
        self.assertEqual(exposicion['exposicion_por_simbolo']['GOOGL'], 500)
        self.assertEqual(len(exposicion['simbolos_activos']), 2)
    
    # ===== TESTS DE CORRELACIÓN =====
    def test_calcular_correlacion_mismo_sector_tech(self):
        """Test correlación alta para mismo sector"""
        corr = self.risk_manager.calcular_correlacion_aproximada('NVDA', 'AMD')
        self.assertEqual(corr, 0.85)
    
    def test_calcular_correlacion_sectores_relacionados(self):
        """Test correlación media para sectores relacionados"""
        corr = self.risk_manager.calcular_correlacion_aproximada('MSFT', 'NET')
        self.assertEqual(corr, 0.70)
    
    def test_calcular_correlacion_sectores_diferentes(self):
        """Test correlación baja para sectores diferentes"""
        corr = self.risk_manager.calcular_correlacion_aproximada('NVDA', 'SQ')
        self.assertEqual(corr, 0.30)
    
    def test_calcular_correlacion_simbolos_desconocidos(self):
        """Test correlación default para símbolos no mapeados"""
        corr = self.risk_manager.calcular_correlacion_aproximada('XXX', 'YYY')
        self.assertEqual(corr, 0.40)
    
    # ===== TESTS DE VERIFICACIÓN DE HORARIO =====
    @patch('risk_manager.datetime')
    def test_verificar_horario_trading_horario_valido(self, mock_datetime):
        """Test horario válido de trading"""
        # Configurar mock para martes 16:00
        mock_now = Mock()
        mock_now.hour = 16
        mock_now.minute = 0
        mock_now.weekday.return_value = 1  # Martes
        mock_datetime.now.return_value = mock_now
        
        ok, mensaje = self.risk_manager.verificar_horario_trading()
        
        self.assertTrue(ok)
        self.assertEqual(mensaje, "Horario óptimo para trading")
    
    @patch('risk_manager.datetime')
    def test_verificar_horario_trading_fin_de_semana(self, mock_datetime):
        """Test horario en fin de semana"""
        # Configurar mock para sábado
        mock_now = Mock()
        mock_now.weekday.return_value = 5  # Sábado
        mock_datetime.now.return_value = mock_now
        
        ok, mensaje = self.risk_manager.verificar_horario_trading()
        
        self.assertFalse(ok)
        self.assertEqual(mensaje, "Mercado cerrado - Fin de semana")
    
    @patch('risk_manager.datetime')
    def test_verificar_horario_trading_fuera_de_horario(self, mock_datetime):
        """Test fuera del horario de trading"""
        # Configurar mock para martes 23:00
        mock_now = Mock()
        mock_now.hour = 23
        mock_now.weekday.return_value = 1  # Martes
        mock_datetime.now.return_value = mock_now
        
        ok, mensaje = self.risk_manager.verificar_horario_trading()
        
        self.assertFalse(ok)
        self.assertIn("Fuera de horario", mensaje)
    
    @patch('risk_manager.datetime')
    def test_verificar_horario_trading_primera_hora(self, mock_datetime):
        """Test primera hora del mercado cuando está configurado evitarla"""
        # Configurar mock para martes 15:30
        mock_now = Mock()
        mock_now.hour = 15
        mock_now.minute = 30
        mock_now.weekday.return_value = 1
        mock_datetime.now.return_value = mock_now
        
        self.risk_manager.evitar_primera_hora = True
        ok, mensaje = self.risk_manager.verificar_horario_trading()
        
        self.assertFalse(ok)
        self.assertEqual(mensaje, "Primera hora del mercado - Alta volatilidad")
    
    # ===== TESTS DE FACTOR DE AJUSTE DINÁMICO =====
    def test_calcular_factor_ajuste_dinamico_sin_perdidas(self):
        """Test factor de ajuste cuando no hay pérdidas"""
        with patch.object(self.risk_manager, 'get_metricas_dia') as mock_metricas:
            mock_metricas.return_value = {
                'pnl_porcentaje': 1.0,
                'trades_totales': 3,
                'win_rate': 0.6
            }
            
            factor = self.risk_manager.calcular_factor_ajuste_dinamico()
            
            self.assertEqual(factor, 1.0)
    
    def test_calcular_factor_ajuste_dinamico_con_perdidas_pequenas(self):
        """Test factor de ajuste con pérdidas pequeñas"""
        with patch.object(self.risk_manager, 'get_metricas_dia') as mock_metricas:
            mock_metricas.return_value = {
                'pnl_porcentaje': -1.5,
                'trades_totales': 4,
                'win_rate': 0.5
            }
            
            factor = self.risk_manager.calcular_factor_ajuste_dinamico()
            
            self.assertEqual(factor, 0.75)
    
    def test_calcular_factor_ajuste_dinamico_con_perdidas_grandes(self):
        """Test factor de ajuste con pérdidas grandes"""
        with patch.object(self.risk_manager, 'get_metricas_dia') as mock_metricas:
            mock_metricas.return_value = {
                'pnl_porcentaje': -2.5,
                'trades_totales': 5,
                'win_rate': 0.2
            }
            
            factor = self.risk_manager.calcular_factor_ajuste_dinamico()
            
            # 0.5 por pérdidas * 0.7 por win rate = 0.35
            self.assertAlmostEqual(factor, 0.35, places=2)
    
    def test_calcular_factor_ajuste_dinamico_con_muchos_trades(self):
        """Test factor de ajuste cuando ya se hicieron muchos trades"""
        with patch.object(self.risk_manager, 'get_metricas_dia') as mock_metricas:
            mock_metricas.return_value = {
                'pnl_porcentaje': 0.5,
                'trades_totales': 12,
                'win_rate': 0.6
            }
            
            factor = self.risk_manager.calcular_factor_ajuste_dinamico()
            
            self.assertEqual(factor, 0.8)  # Reducción por muchos trades
    
    # ===== TESTS DE STOP LOSS DINÁMICO =====
    def test_calcular_stop_loss_dinamico_buy(self):
        """Test cálculo de stop loss para compra"""
        resultado = self.risk_manager.calcular_stop_loss_dinamico('AAPL', 100, 'BUY', 0.02)
        
        # Para BUY, stop loss debe ser menor que precio
        self.assertLess(resultado['stop_loss'], 100)
        self.assertGreaterEqual(resultado['stop_loss'], 98)
        
        # Take profit debe ser mayor
        self.assertGreater(resultado['take_profit'], 100)
        
        # Verificar ratio
        self.assertEqual(resultado['riesgo_beneficio'], 1.5)
    
    def test_calcular_stop_loss_dinamico_sell(self):
        """Test cálculo de stop loss para venta"""
        resultado = self.risk_manager.calcular_stop_loss_dinamico('AAPL', 100, 'SELL', 0.02)
        
        # Para SELL, stop loss debe ser mayor que precio
        self.assertGreater(resultado['stop_loss'], 100)
        self.assertLessEqual(resultado['stop_loss'], 102)
        
        # Take profit debe ser menor
        self.assertLess(resultado['take_profit'], 100)
        
        # Verificar ratio
        self.assertEqual(resultado['riesgo_beneficio'], 1.5)


class TestEvaluarTradeCompleto(unittest.TestCase):
    """Tests específicos para el método evaluar_trade_completo"""
    
    def setUp(self):
        """Configuración para tests de evaluar_trade_completo"""
        self.mock_supabase = Mock()
        self.patcher = patch('risk_management.risk_manager.supabase', self.mock_supabase)
        self.patcher.start()
        
        # Capital por defecto
        self.mock_supabase.table.return_value.select.return_value.execute.return_value.data = [
            {'capital': 1000}
        ]
        
        self.risk_manager = RiskManager(capital_inicial=1000)
    
    def tearDown(self):
        self.patcher.stop()
    
    @patch('risk_manager.datetime')
    def test_evaluar_trade_rechazado_por_horario(self, mock_datetime):
        """Test trade rechazado por estar fuera de horario"""
        # Configurar fin de semana
        mock_now = Mock()
        mock_now.weekday.return_value = 6  # Domingo
        mock_datetime.now.return_value = mock_now
        
        aprobado, mensaje, ajustes = self.risk_manager.evaluar_trade_completo(
            'AAPL', 'BUY', 10, 150, 0.8, 'Consenso fuerte'
        )
        
        self.assertFalse(aprobado)
        self.assertIn("Mercado cerrado", mensaje)
    
    def test_evaluar_trade_rechazado_por_perdida_diaria(self):
        """Test trade rechazado por límite de pérdida diaria"""
        # Mock métricas con pérdidas altas
        with patch.object(self.risk_manager, 'get_metricas_dia') as mock_metricas:
            mock_metricas.return_value = {
                'pnl_porcentaje': -6.0,  # Más del 5%
                'trades_totales': 10
            }
            
            with patch.object(self.risk_manager, 'verificar_horario_trading') as mock_horario:
                mock_horario.return_value = (True, "OK")
                
                aprobado, mensaje, ajustes = self.risk_manager.evaluar_trade_completo(
                    'AAPL', 'BUY', 10, 150, 0.8, 'Consenso fuerte'
                )
                
                self.assertFalse(aprobado)
                self.assertIn("Límite de pérdida diaria", mensaje)


if __name__ == '__main__':
    unittest.main()

